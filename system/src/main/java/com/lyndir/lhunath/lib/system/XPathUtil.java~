package net.link.safeonline.performance.drivers;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.xml.XMLConstants;
import javax.xml.namespace.NamespaceContext;
import javax.xml.namespace.QName;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

/**
 * Utilities for evaluating XPath on XHTML.
 * 
 * @author mbillemo
 */
public class XPathUtil {

	private XPath xpath;

	/**
	 * Create a new XPathUtil instance.
	 */
	public XPathUtil() {

		this.xpath = XPathFactory.newInstance().newXPath();
		this.xpath.setNamespaceContext(new XHTMLContext());
	}

	/**
	 * Evaluate an {@link XPath} expression and return the text from the
	 * selected nodes.
	 * 
	 * @param expressionFormat
	 *            The XPath expression format. See
	 *            {@link String#format(String, Object...)}.
	 * @param context
	 *            The context to evaluate the XPath expression under.
	 * @param arguments
	 *            The data used to satisfy the format parameters in the
	 *            expressionFormat.
	 */
	public Boolean evaluateBoolean(String expressionFormat, Object context,
			Object... arguments) throws XPathExpressionException {

		return (Boolean) evaluate(expressionFormat, context,
				XPathConstants.BOOLEAN, arguments);
	}

	/**
	 * Evaluate an {@link XPath} expression and return the first of the selected
	 * nodes.
	 * 
	 * @param expressionFormat
	 *            The XPath expression format. See
	 *            {@link String#format(String, Object...)}.
	 * @param context
	 *            The context to evaluate the XPath expression under.
	 * @param arguments
	 *            The data used to satisfy the format parameters in the
	 *            expressionFormat.
	 */
	public Node evaluateNode(String expressionFormat, Object context,
			Object... arguments) throws XPathExpressionException {

		return (Node) evaluate(expressionFormat, context, XPathConstants.NODE,
				arguments);
	}

	/**
	 * Evaluate an {@link XPath} expression and return a list of the selected
	 * nodes.
	 * 
	 * @param expressionFormat
	 *            The XPath expression format. See
	 *            {@link String#format(String, Object...)}.
	 * @param context
	 *            The context to evaluate the XPath expression under.
	 * @param arguments
	 *            The data used to satisfy the format parameters in the
	 *            expressionFormat.
	 */
	public List<Node> evaluateNodeList(String expressionFormat, Object context,
			Object... arguments) throws XPathExpressionException {

		List<Node> nodeList = new ArrayList<Node>();
		NodeList annoyingNodeList = (NodeList) evaluate(expressionFormat,
				context, XPathConstants.NODESET, arguments);

		for (int node = 0; node < annoyingNodeList.getLength(); ++node)
			nodeList.add(annoyingNodeList.item(node));

		return nodeList;
	}

	/**
	 * Evaluate an {@link XPath} expression and return the text from the
	 * selected nodes.
	 * 
	 * @param expressionFormat
	 *            The XPath expression format. See
	 *            {@link String#format(String, Object...)}.
	 * @param context
	 *            The context to evaluate the XPath expression under.
	 * @param arguments
	 *            The data used to satisfy the format parameters in the
	 *            expressionFormat.
	 */
	public Double evaluateNumber(String expressionFormat, Object context,
			Object... arguments) throws XPathExpressionException {

		return (Double) evaluate(expressionFormat, context,
				XPathConstants.NUMBER, arguments);
	}

	/**
	 * Evaluate an {@link XPath} expression and return the text from the
	 * selected nodes.
	 * 
	 * @param expressionFormat
	 *            The XPath expression format. See
	 *            {@link String#format(String, Object...)}.
	 * @param context
	 *            The context to evaluate the XPath expression under.
	 * @param arguments
	 *            The data used to satisfy the format parameters in the
	 *            expressionFormat.
	 */
	public String evaluateString(String expressionFormat, Object context,
			Object... arguments) throws XPathExpressionException {

		return (String) evaluate(expressionFormat, context,
				XPathConstants.STRING, arguments);
	}

	/**
	 * Evaluate an {@link XPath} expression and return the selected nodes as the
	 * given result type.
	 * 
	 * @param expressionFormat
	 *            The XPath expression format. See
	 *            {@link String#format(String, Object...)}.
	 * @param context
	 *            The context to evaluate the XPath expression under.
	 * @param result
	 *            The type of result to return the selected nodes as.
	 * @param arguments
	 *            The data used to satisfy the format parameters in the
	 *            expressionFormat.
	 */
	private Object evaluate(String expressionFormat, Object context,
			QName result, Object... arguments) throws XPathExpressionException {

		String expression = String.format(expressionFormat, arguments);

		if (context instanceof InputSource)
			return this.xpath.evaluate(expression, (InputSource) context,
					result);

		return this.xpath.evaluate(expression, context, result);
	}

	public class XHTMLContext implements NamespaceContext {

		private Map<String, String> namespaces = new HashMap<String, String>();

		/**
		 * Create a new AuthDriver.XHTMLContext instance.
		 */
		public XHTMLContext() {

			this.namespaces.put(XMLConstants.XMLNS_ATTRIBUTE,
					XMLConstants.XMLNS_ATTRIBUTE_NS_URI);
			this.namespaces.put(XMLConstants.XML_NS_PREFIX,
					XMLConstants.XML_NS_URI);
			this.namespaces.put(XMLConstants.DEFAULT_NS_PREFIX,
					"http://www.w3.org/1999/xhtml");
			this.namespaces.put("xhtml", "http://www.w3.org/1999/xhtml");
		}

		/**
		 * @{inheritDoc}
		 */
		public String getNamespaceURI(String prefix) {

			return this.namespaces.get(prefix);
		}

		/**
		 * @{inheritDoc}
		 */
		public String getPrefix(String namespaceURI) {

			for (Map.Entry<String, String> namespace : this.namespaces
					.entrySet())
				if (namespaceURI.equals(namespace.getValue()))
					return namespace.getKey();

			return null;
		}

		/**
		 * @return
		 * @{inheritDoc}
		 */
		public Iterator<String> getPrefixes(String namespaceURI) {

			List<String> URIs = new ArrayList<String>();
			for (Map.Entry<String, String> namespace : this.namespaces
					.entrySet())
				if (namespaceURI.equals(namespace.getValue()))
					URIs.add(namespace.getKey());

			return URIs.iterator();
		}

	}
}
